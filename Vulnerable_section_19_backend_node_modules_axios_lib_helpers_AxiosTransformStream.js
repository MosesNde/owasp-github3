 
 import stream from 'stream';
 import utils from '../utils.js';
import throttle from './throttle.js';
import speedometer from './speedometer.js';
 
 const kInternals = Symbol('internals');
 
       readableHighWaterMark: options.chunkSize
     });
 
    const self = this;

     const internals = this[kInternals] = {
      length: options.length,
       timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
       chunkSize: options.chunkSize,
       maxRate: options.maxRate,
       minChunkSize: options.minChunkSize,
       onReadCallback: null
     };
 
    const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);

     this.on('newListener', event => {
       if (event === 'progress') {
         if (!internals.isCaptured) {
           internals.isCaptured = true;
         }
       }
     });

    let bytesNotified = 0;

    internals.updateProgress = throttle(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self.destroyed) return;

      const rate = _speedometer(progressBytes);

      bytesNotified = bytesTransferred;

      process.nextTick(() => {
        self.emit('progress', {
          loaded: bytesTransferred,
          total: totalBytes,
          progress: totalBytes ? (bytesTransferred / totalBytes) : undefined,
          bytes: progressBytes,
          rate: rate ? rate : undefined,
          estimated: rate && totalBytes && bytesTransferred <= totalBytes ?
            (totalBytes - bytesTransferred) / rate : undefined,
          lengthComputable: totalBytes != null
        });
      });
    }, internals.ticksRate);

    const onFinish = () => {
      internals.updateProgress.call(true);
    };

    this.once('end', onFinish);
    this.once('error', onFinish);
   }
 
   _read(size) {
   }
 
   _transform(chunk, encoding, callback) {
    const self = this;
     const internals = this[kInternals];
     const maxRate = internals.maxRate;
 
     const bytesThreshold = (maxRate / divider);
     const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
 
    function pushChunk(_chunk, _callback) {
       const bytes = Buffer.byteLength(_chunk);
       internals.bytesSeen += bytes;
       internals.bytes += bytes;
 
      if (internals.isCaptured) {
        internals.updateProgress();
      }
 
      if (self.push(_chunk)) {
         process.nextTick(_callback);
       } else {
         internals.onReadCallback = () => {
       }
     });
   }

  setLength(length) {
    this[kInternals].length = +length;
    return this;
  }
 }
 
 export default AxiosTransformStream;