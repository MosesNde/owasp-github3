// Axios v1.7.2 Copyright (c) 2024 Matt Zabriskie and contributors
 (function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' && define.amd ? define(factory) :
   var isThenable = function isThenable(thing) {
     return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing["catch"]);
   };
   var utils$1 = {
     isArray: isArray,
     isArrayBuffer: isArrayBuffer,
     isSpecCompliantForm: isSpecCompliantForm,
     toJSONObject: toJSONObject,
     isAsyncFn: isAsyncFn,
    isThenable: isThenable
   };
 
   /**
   function throttle(fn, freq) {
     var timestamp = 0;
     var threshold = 1000 / freq;
    var timer = null;
    return function throttled() {
      var _arguments = arguments;
      var force = this === true;
       var now = Date.now();
      if (force || now - timestamp > threshold) {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        timestamp = now;
        return fn.apply(null, arguments);
       }
      if (!timer) {
        timer = setTimeout(function () {
          timer = null;
          timestamp = Date.now();
          return fn.apply(null, _arguments);
        }, threshold - (now - timestamp));
       }
     };
   }
 
  var progressEventReducer = (function (listener, isDownloadStream) {
     var freq = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
     var bytesNotified = 0;
     var _speedometer = speedometer(50, 250);
       var rate = _speedometer(progressBytes);
       var inRange = loaded <= total;
       bytesNotified = loaded;
      var data = {
         loaded: loaded,
         total: total,
         progress: total ? loaded / total : undefined,
         estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
         event: e,
         lengthComputable: total != null
      };
      data[isDownloadStream ? 'download' : 'upload'] = true;
       listener(data);
     }, freq);
  });
 
   var isURLSameOrigin = platform.hasStandardBrowserEnv ?
   // Standard browser envs have full support of the APIs needed to test
       var _config = resolveConfig(config);
       var requestData = _config.data;
       var requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      var responseType = _config.responseType;
       var onCanceled;
       function done() {
        if (_config.cancelToken) {
          _config.cancelToken.unsubscribe(onCanceled);
        }
        if (_config.signal) {
          _config.signal.removeEventListener('abort', onCanceled);
        }
       }
       var request = new XMLHttpRequest();
       request.open(_config.method.toUpperCase(), _config.url, true);
         if (!request) {
           return;
         }
        reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, _config, request));
 
         // Clean up request
         request = null;
       request.onerror = function handleError() {
         // Real errors are hidden from us by the browser
         // onerror should only fire if it's a network error
        reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, _config, request));
 
         // Clean up request
         request = null;
         if (_config.timeoutErrorMessage) {
           timeoutErrorMessage = _config.timeoutErrorMessage;
         }
        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, _config, request));
 
         // Clean up request
         request = null;
       }
 
       // Handle progress if needed
      if (typeof _config.onDownloadProgress === 'function') {
        request.addEventListener('progress', progressEventReducer(_config.onDownloadProgress, true));
       }
 
       // Not all browsers support upload events
      if (typeof _config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', progressEventReducer(_config.onUploadProgress));
       }
       if (_config.cancelToken || _config.signal) {
         // Handle cancellation
   var trackStream = function trackStream(stream, chunkSize, onProgress, onFinish, encode) {
     var iterator = readBytes(stream, chunkSize, encode);
     var bytes = 0;
     return new ReadableStream({
      type: 'bytes',
       pull: function pull(controller) {
         return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var _yield$iterator$next, done, value, len;
           return _regeneratorRuntime().wrap(function _callee2$(_context3) {
             while (1) switch (_context3.prev = _context3.next) {
               case 0:
                _context3.next = 2;
                 return iterator.next();
              case 2:
                 _yield$iterator$next = _context3.sent;
                done = _yield$iterator$next.done;
                 value = _yield$iterator$next.value;
                if (!done) {
                  _context3.next = 9;
                   break;
                 }
                 controller.close();
                onFinish();
                 return _context3.abrupt("return");
              case 9:
                 len = value.byteLength;
                onProgress && onProgress(bytes += len);
                 controller.enqueue(new Uint8Array(value));
              case 12:
               case "end":
                 return _context3.stop();
             }
          }, _callee2);
         }))();
       },
       cancel: function cancel(reason) {
        onFinish(reason);
         return iterator["return"]();
       }
     }, {
       highWaterMark: 2
     });
   };
 
  var fetchProgressDecorator = function fetchProgressDecorator(total, fn) {
    var lengthComputable = total != null;
    return function (loaded) {
      return setTimeout(function () {
        return fn({
          lengthComputable: lengthComputable,
          total: total,
          loaded: loaded
        });
      });
    };
  };
   var isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
   var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';
 
       return _ref.apply(this, arguments);
     };
   }()));
  var supportsRequestStream = isReadableStreamSupported && function () {
     var duplexAccessed = false;
     var hasContentType = new Request(platform.origin, {
       body: new ReadableStream(),
       }
     }).headers.has('Content-Type');
     return duplexAccessed && !hasContentType;
  }();
   var DEFAULT_CHUNK_SIZE = 64 * 1024;
  var supportsResponseStream = isReadableStreamSupported && !!function () {
    try {
      return utils$1.isReadableStream(new Response('').body);
    } catch (err) {
      // return undefined
    }
  }();
   var resolvers = {
     stream: supportsResponseStream && function (res) {
       return res.body;
           case 7:
             return _context2.abrupt("return", _context2.sent.byteLength);
           case 8:
            if (!utils$1.isArrayBufferView(body)) {
               _context2.next = 10;
               break;
             }
   }();
   var fetchAdapter = isFetchSupported && ( /*#__PURE__*/function () {
     var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(config) {
      var _resolveConfig, url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, _resolveConfig$withCr, withCredentials, fetchOptions, _ref5, _ref6, composedSignal, stopTimeout, finished, request, onFinish, requestContentLength, _request, contentTypeHeader, response, isStreamResponse, options, responseContentLength, responseData;
       return _regeneratorRuntime().wrap(function _callee4$(_context4) {
         while (1) switch (_context4.prev = _context4.next) {
           case 0:
               headers.setContentType(contentTypeHeader);
             }
             if (_request.body) {
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(requestContentLength, progressEventReducer(onUploadProgress)), null, encodeText);
             }
           case 15:
             if (!utils$1.isString(withCredentials)) {
              withCredentials = withCredentials ? 'cors' : 'omit';
             }
             request = new Request(url, _objectSpread2(_objectSpread2({}, fetchOptions), {}, {
               signal: composedSignal,
               method: method.toUpperCase(),
               headers: headers.normalize().toJSON(),
               body: data,
               duplex: "half",
              withCredentials: withCredentials
             }));
             _context4.next = 19;
             return fetch(request);
                 options[prop] = response[prop];
               });
               responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));
              response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(responseContentLength, progressEventReducer(onDownloadProgress, true)), isStreamResponse && onFinish, encodeText), options);
             }
             responseType = responseType || 'text';
             _context4.next = 25;
     });
   }
 
  var VERSION = "1.7.2";
 
   var validators$1 = {};
 