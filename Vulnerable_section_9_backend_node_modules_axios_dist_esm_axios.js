// Axios v1.7.2 Copyright (c) 2024 Matt Zabriskie and contributors
 function bind(fn, thisArg) {
   return function wrap() {
     return fn.apply(thisArg, arguments);
 const isThenable = (thing) =>
   thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
 
 const utils$1 = {
   isArray,
   isArrayBuffer,
   isSpecCompliantForm,
   toJSONObject,
   isAsyncFn,
  isThenable
 };
 
 /**
  */
 function throttle(fn, freq) {
   let timestamp = 0;
  const threshold = 1000 / freq;
  let timer = null;
  return function throttled() {
    const force = this === true;
 
     const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
       }
      timestamp = now;
      return fn.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, arguments);
      }, threshold - (now - timestamp));
     }
   };
 }
 
 const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
       rate: rate ? rate : undefined,
       estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
       event: e,
      lengthComputable: total != null
     };
 
    data[isDownloadStream ? 'download' : 'upload'] = true;

     listener(data);
   }, freq);
 };
 
 const isURLSameOrigin = platform.hasStandardBrowserEnv ?
 
 // Standard browser envs have full support of the APIs needed to test
     const _config = resolveConfig(config);
     let requestData = _config.data;
     const requestHeaders = AxiosHeaders$2.from(_config.headers).normalize();
    let {responseType} = _config;
     let onCanceled;
     function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
 
      if (_config.signal) {
        _config.signal.removeEventListener('abort', onCanceled);
      }
     }
 
     let request = new XMLHttpRequest();
         return;
       }
 
      reject(new AxiosError$1('Request aborted', AxiosError$1.ECONNABORTED, _config, request));
 
       // Clean up request
       request = null;
     request.onerror = function handleError() {
       // Real errors are hidden from us by the browser
       // onerror should only fire if it's a network error
      reject(new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, _config, request));
 
       // Clean up request
       request = null;
       reject(new AxiosError$1(
         timeoutErrorMessage,
         transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        _config,
         request));
 
       // Clean up request
     }
 
     // Handle progress if needed
    if (typeof _config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(_config.onDownloadProgress, true));
     }
 
     // Not all browsers support upload events
    if (typeof _config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(_config.onUploadProgress));
     }
 
     if (_config.cancelToken || _config.signal) {
   const iterator = readBytes(stream, chunkSize, encode);
 
   let bytes = 0;
 
   return new ReadableStream({
    type: 'bytes',

     async pull(controller) {
      const {done, value} = await iterator.next();
 
      if (done) {
        controller.close();
        onFinish();
        return;
      }
 
      let len = value.byteLength;
      onProgress && onProgress(bytes += len);
      controller.enqueue(new Uint8Array(value));
     },
     cancel(reason) {
      onFinish(reason);
       return iterator.return();
     }
   }, {
     highWaterMark: 2
   })
 };
 
const fetchProgressDecorator = (total, fn) => {
  const lengthComputable = total != null;
  return (loaded) => setTimeout(() => fn({
    lengthComputable,
    total,
    loaded
  }));
};

 const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
 const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';
 
     async (str) => new Uint8Array(await new Response(str).arrayBuffer())
 );
 
const supportsRequestStream = isReadableStreamSupported && (() => {
   let duplexAccessed = false;
 
   const hasContentType = new Request(platform.origin, {
   }).headers.has('Content-Type');
 
   return duplexAccessed && !hasContentType;
})();
 
 const DEFAULT_CHUNK_SIZE = 64 * 1024;
 
const supportsResponseStream = isReadableStreamSupported && !!(()=> {
  try {
    return utils$1.isReadableStream(new Response('').body);
  } catch(err) {
    // return undefined
  }
})();
 
 const resolvers = {
   stream: supportsResponseStream && ((res) => res.body)
     return (await new Request(body).arrayBuffer()).byteLength;
   }
 
  if(utils$1.isArrayBufferView(body)) {
     return body.byteLength;
   }
 
       }
 
       if (_request.body) {
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(
           requestContentLength,
          progressEventReducer(onUploadProgress)
        ), null, encodeText);
       }
     }
 
     if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'cors' : 'omit';
     }
 
     request = new Request(url, {
       headers: headers.normalize().toJSON(),
       body: data,
       duplex: "half",
      withCredentials
     });
 
     let response = await fetch(request);
 
       const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));
 
       response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(
          responseContentLength,
          progressEventReducer(onDownloadProgress, true)
        ), isStreamResponse && onFinish, encodeText),
         options
       );
     }
   });
 }
 
const VERSION$1 = "1.7.2";
 
 const validators$1 = {};
 